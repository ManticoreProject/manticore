(* future1-work-sharing.hlop
 * 
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * Work sharing for one-toucher futures.
 *)

#include "types.def"
#include "locked-queue.def"
#include "futures.def"
#include "tags.def"
#include "debugging.def"
#include "fgs.def"

extern void *ListVProcs (void *) __attribute__((alloc));

define @future1-work-sharing ( / exh : exh) : future_spawn_fn =

 (* shared queue for the workers *)
  let q : locked_queue = @locked-queue-new ( / exh)

  fun steal (fut : future / exh : exh) : () =
      let tmp : any = CAS (&0(fut), EMPTY_F, STOLEN_F)
      if Equal (tmp, EMPTY_F) 
         then let f : thunk = #1(fut)
              do #1(fut) := (thunk) $0
       	      (* need exn handler for thunk. *)
              (* let exh : exh = ... *)
              let resultLocal : any = apply f (UNIT / exh)
              let result : any = promote (resultLocal)
              let tmpX : any = CAS(&0(fut), STOLEN_F, result)
              if Equal (tmpX, STOLEN_F)            
                 then return ()
                 else do #0(fut) := result
	              let k : fiber = (fiber) tmpX
                      do @locked-queue-enqueue (q, k / exh)
                      return ()
          else (* future cell is already full *)
		return ()

 (* spawn a future *)
  fun spawn (fut : future / exh : exh) : unit = 
     (* wrapper function that touches the future *)
      fun wrapper (_ : unit / exh : exh) : unit =
         (* FIXME: do something about the exception handler *)
          do apply steal (fut / exh)
          return (UNIT)
     (* construct a fiber for the future and put it on the work queue *)
      let k : fiber = @fiber (wrapper / exh)
      do @locked-queue-enqueue (q, k / exh)
      return (UNIT)

 (* Initialize fiber-group storage. *)
  let parentFGS : fgs = @get-fgs (host_vproc / exh)
 (* fiber group storage for the future scheduler *)
  let parent : option = SOME (parentFGS)
  let fgs : fgs = @new-fgs (TRUE, parent / exh)
 (* add the spawn function to the fiber group storage *)
  fun init (_ : unit / exh : exh) : any = return (spawn)
  let _ : any = @assoc-list-lookup (TAG_SPAWN_FUTURE, init, fgs / exh)

 (* return the scheduler action *)
  fun mkSwitch (self : vproc / exh : exh) : sigact = 
      cont switch (s : signal) =
           cont findWork () =
               let eltOpt : option = @locked-queue-dequeue (q / exh)
               case eltOpt
    	        of NONE => throw findWork ()
		 | SOME (k : fiber) => 
		   @run (self, switch, fgs, k / exh)
               end

           if Equal (s, STOP)
              then throw findWork ()
              else do @locked-queue-enqueue (q, s / exh)
                   let _ : unit = @atomic-yield (self / exh)
                   throw findWork ()
      return (switch)

 (* Initialize the scheduler on the vprocs. *)
  let vps : list = ccall ListVProcs(host_vproc)
  do @scheduler-startup (mkSwitch, fgs, vps / exh)
  return (spawn)
;

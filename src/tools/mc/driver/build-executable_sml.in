(* build-executable.sml
 *
 * COPYRIGHT (c) 2007 The Manticore Project (http://manticore.cs.uchicago.edu)
 * All rights reserved.
 *
 * @configure_input@
 *
 * A wrapper for the commands needed to assemble and link the output
 * of the Manticore compiler.
 *)

structure BuildExecutable : sig

    val build : {
	    verbose : bool,	(* if true, print shell commands to stdout *)
	    asmFile : string,	(* the assembly file generated by the compiler *)
	    outFile : string	(* the name of the executable image. *)
	  } -> OS.Process.status

  end = struct
  
    structure PrintTbl = PrintTable
	structure PrintTblDbg = PrintTableDebug

    val cat = String.concatWith " "

    fun ++ ("", l) = l
      | ++ (opt, l) = opt::l

    infixr ++

    val isCrossCompiler = (@CROSS_COMPILING@ = 1)

    val ccCmd =  "@CC@"

    val cFlags = cat ("@CFLAGS@" ++ "@CFLAG_M64@" ++ [])

    fun ldFlags libName = let
	  val libDirs = List.filter (fn path => OS.FileSys.access (path, [])) [
		  "@prefix@/lib",
		  "@MANTICORE_LIBDIR@",
		  "@MANTICORE_SRCDIR@/lib/parallel-rt/build/" ^ libName
		]
	  val libDirs = List.map (fn path => "-L" ^ path) libDirs
	  val rtLib = "-l" ^ libName
	  in
	    cat (libDirs @ ("@LDFLAGS@" ++ rtLib ++ "@LIBS@" ++ "-lpthread" ++ []))
	  end

    fun systemWithTiming (cmd, mustPrint) = let
        val verbose = mustPrint orelse (Controls.get BasicControl.verbose > 0)
        val inclusiveStart = Time.now()
        val _ = (if verbose
	         then TextIO.print(cmd ^ "\n")
	         else ())
        val result = OS.Process.system cmd;
    in
        if verbose
        then TextIO.print(concat ["Compile finished in: ",
                                  (Time.toString (Time.- (Time.now(), inclusiveStart))),
                                  "\n"])
        else ();
        result
    end

    fun cmd asmFile = let
	  val gcStats = Controls.get BasicControl.gcStats
	  val logging = Controls.get BasicControl.logging
	  val debug = Controls.get BasicControl.debug
	  val perf = Controls.get BasicControl.perf
	  val (cFlags, libName) = (case (gcStats, logging, debug, perf)
		 of (true, false, false, false) => (cFlags, "mcrt-stats")
		  | (_, false, false, false) => (cFlags, "mcrt")
		  | (_, true, false, false) => (cFlags, "mcrt-log")
		  | (_, false, true, false) => ("-g "^cFlags, "mcrt-debug")
		  | (_, true, true, false) => ("-g "^cFlags, "mcrt-log-debug")
		  | (_, _, _, true) => (cFlags, "mcrt-perf")
		(* end case *))
	  val filename = OS.FileSys.tmpName()
      val filenamec = concat[filename,".c"]
      val filenameo = concat[filename,".o"]  
	  val gccfilename = concat ["gcc @CFLAGS@ @LIBS@ @CFLAG_M64@ -I @MANTICORE_SRCDIR@/lib/parallel-rt/gc -I @MANTICORE_SRCDIR@/lib/parallel-rt/include/ -I @MANTICORE_SRCDIR@/include -o ",filenameo," -std=c99 -c ",filenamec]
	  val _ = PrintTbl.print filenamec
	  val _ = systemWithTiming (gccfilename, false)
	  
	  fun tableFiles () =( if (debug) 
      then (
      let
		  val filenamedebug = OS.FileSys.tmpName()
		  val filenamedebugc = concat[filenamedebug,".c"]
		  val filenamedebugo = concat[filenamedebug,".o"]  
		  val gccfilenamedebug = concat ["gcc @CFLAGS@ @LIBS@ @CFLAG_M64@ -I @MANTICORE_SRCDIR@/lib/parallel-rt/gc -I @MANTICORE_SRCDIR@/lib/parallel-rt/include/ -I @MANTICORE_SRCDIR@/include -o ",filenamedebugo," -std=c99 -c ",filenamedebugc]
		  val _ = PrintTblDbg.print filenamedebugc
		  val _ = systemWithTiming (gccfilenamedebug, false)
	  in
          concat[filenameo," ",filenamedebugo]
      end
      )
      else (
          filenameo
      )
      )
      val files = tableFiles ()
	  in
	    cat [ccCmd, cFlags, asmFile,files, ldFlags libName]
	  end

    fun build {verbose, asmFile, outFile} = if isCrossCompiler
	  then (
	    TextIO.output(TextIO.stdErr, "cross compiler cannot produce executables\n");
	    OS.Process.failure)
	  else let
	    val cmd' = cat[cmd asmFile, " -o ", outFile]
	    in
	      systemWithTiming (cmd', verbose)
	    end

  end
